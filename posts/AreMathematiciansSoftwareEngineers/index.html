<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  
  <link rel="stylesheet" href="/css/franklin.css">
  <link rel="stylesheet" href="/css/basic.css">
  <link rel="icon" href="/assets/favicon.png">
  <script data-goatcounter="https://bblog.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
   <title>Are Mathematicians Software Engineers in Disguise?</title>  
</head>
<body>
  <header>
<div class="blog-name"><a href="/"> Simple Complexity</a></div>
<nav>
  <ul>
    <li><a href="/about/">About</a></li>
    <li><a href="/">Blog entries</a></li> 
  </ul>
  <img src="/assets/hamburger.svg" id="menu-icon">
</nav>
</header>


<!-- Content appended here -->
<div class="franklin-content"><h1 id="are_mathematicians_software_engineers_in_disguise"><a href="#are_mathematicians_software_engineers_in_disguise" class="header-anchor">Are Mathematicians Software Engineers in Disguise?</a></h1>
<p>By <strong>Samuel Belko</strong>, published on April 6, 2025.</p>
<blockquote>
<p>Mathematics has always been about coming up with abstractions that enable us to think more efficiently, communicate precisely, solve hard problems, and reach a stable consensus as to whether our claims are justified.   Jeremy Avigad, in &#40;<span class="bibref"><a href="#ja">Mathematics and the formal turn</a></span>&#41;</p>
</blockquote>
<p>There is a striking similiarity between extending a complicated codebase and writing down  complicated mathematical theories. The developer and mathematician are both challenged to come up with a structure that a human mind can parse, and that encodes relations to already existing interfaces, we are building on top of. In programming we are always coding against  some lower level interfaces or utilities from some libraries. Similarly in math, we import proven statements into our scope and reference them in our proofs.</p>
<p>In math, people often introduce definitions that generalize ideas and allow for proving statements <em>at one fell swoop</em>. Arguably, creating abstraction hierarchies is the reason why can efficiently learn existing math. Similarly, in programming,  we introduce new interfaces that require some generic properties, that are sufficient for the implementation details.</p>
<p>Code refactoring with the goal of reducing dependencies and reusing code can be compared with decoposing a complicated proof into simpler lemmas, which do not need the access the full scope of the argument. In both cases, we are curving out some of the complexity into  its own local scope.</p>
<p>When mathematicians introduce new notation and conventions, they are essentially  <em>programming bottom up</em>, changing the langage  to suit a problem, as Paul Graham expressed it in <a href="https://www.paulgraham.com/progbot.html">Language and program evolve together</a>. This is a common programming pattern, resulting  in developing libraries, whose functionalities compose.</p>
<p>The analogies I touched upon originate from &#40;<span class="bibref"><a href="#ja">Mathematics and the formal turn</a></span>&#41;, which discusses the future of mathematics, in light of formal verification methods.</p>
<p>I hope, you find the topic as intriguing as I did, when I saw the similarites for the first time.</p>
<h2 id="references"><a href="#references" class="header-anchor">References</a></h2>
<ul>
<li><p><a id="ja" class="anchor"></a> Jeremy Avigad. Mathematics and the formal turn. 2023. <a href="https://arxiv.org/abs/2311.00007">arXiv</a></p>
</li>
</ul>
<div class="page-foot">
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Samuel Belko. Last modified: April 06, 2025.
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
</div>
</div><!-- CONTENT ENDS HERE -->
    
    
  </body>
</html>
