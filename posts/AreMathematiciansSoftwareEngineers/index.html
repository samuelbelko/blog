<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  
  <link rel="stylesheet" href="/css/franklin.css">
  <link rel="stylesheet" href="/css/basic.css">
  <link rel="icon" href="/assets/favicon.png">
  <script data-goatcounter="https://bblog.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
   <title>Are Mathematicians Software Engineers in Disguise?</title>  
</head>
<body>
  <header>
<div class="blog-name"><a href="/"> Simple Complexity</a></div>
<nav>
  <ul>
    <li><a href="/about/">About</a></li>
    <li><a href="/">Blog entries</a></li> 
  </ul>
  <img src="/assets/hamburger.svg" id="menu-icon">
</nav>
</header>


<!-- Content appended here -->
<div class="franklin-content"><h1 id="are_mathematicians_software_engineers_in_disguise"><a href="#are_mathematicians_software_engineers_in_disguise" class="header-anchor">Are Mathematicians Software Engineers in Disguise?</a></h1>
<p>By <strong>Samuel Belko</strong>, published on April 6, 2025.</p>
<blockquote>
<p>Mathematics has always been about coming up with abstractions that enable us to think more efficiently, communicate precisely, solve hard problems, and reach a stable consensus as to whether our claims are justified.<br />â€“ Jeremy Avigad, in <span class="bibref"><a href="#ja">Mathematics and the formal turn</a></span></p>
</blockquote>
<p>There is a striking similiarity between extending a complicated codebase and writing down  complicated mathematical theories. The developer and mathematician are both challenged to come up with a structure that a human mind can parse, and that encodes the relations to already existing interfaces, that they are building on top of. In programming, we are always coding against some lower level interfaces or utilities from some libraries. Similarly in math, we import proven statements into our scope and reference them in our proofs.</p>
<p>For instance, we can think of refactoring a complicated piece of code as an analogy for a decomposition of a complicated proof into simpler lemmas. Maybe we have identified a repeating construction in some proofs, and we could encapsulate the construction into its own litte lemma. These lemmas do not need to access the full scope of the argument and hopefully lower the overall cognitive load.</p>
<p>When mathematicians introduce new notation and conventions, they are essentially  <em>programming bottom up</em>, changing the langage  to suit a problem, as Paul Graham expressed it in <a href="https://www.paulgraham.com/progbot.html">Language and program evolve together</a>. This is a common programming pattern, resulting  in developing libraries, whose functionalities compose.</p>
<p>Furthermore, we can compare the advices of a well-known mathematician Paul Halmos on formulating clean theory expositions, collected in <span class="bibref"><a href="#ha">How to Write Mathematics</a></span>, with advices for clean software design, discussed in a well-known reference <span class="bibref"><a href="#swe">A Philosophy of Software Design</a></span>. Halmos mentions the following statements about how he is writing mathematics:</p>
<blockquote>
<p>The writer must anticipate and avoid the reader&#39;s difficulties.</p>
</blockquote>
<blockquote>
<p>The best way to start writing, perhaps the only way, is to write in the spiral plan. According to the spiral plan the chapters get written and re-written in the order 1, 2, 1, 2, 3, 1, 2, 3, 4, etc. You think you know how to write Chapter 1, but after you&#39;ve done it and gone on the Chapter 2, you&#39;ll realize that you could have done a better job on Chapter 2 if you had done Chapter 1 differently. There is no help for it but to go back, do Chapter 1 differently, do a better job on Chapter 2, and then dive into Chapter 3. And, of course, you know what will happen: Chapter 3 will show up the weaknesses of Chapters 1 and 2, and there is no help for it ... etc., etc., etc.</p>
</blockquote>
<p>We can contrast the above with statements found in <span class="bibref"><a href="#swe">A Philosophy of Software Design</a></span>, such as:</p>
<blockquote>
<p>One of the most important goals of good design is for a system to be obvious.</p>
</blockquote>
<blockquote>
<p>... most software development projects today use an incremental approach such as agile development, in which the initial design focuses on a small subset of the overall functionality. This subset is designed, implemented, and then evaluated. Problems with the original design are discovered and corrected, then a few more features are designed, implemented and evaluated. Each iteration exposes problems with the existing design, which are fixed before the next set of features is designed.</p>
</blockquote>
<p>We can see that both sources emphasize spending extra effort on redesigning the initial concepts so that at the end, the content as as easy as possible to follow. The contributions are not just a working proof or a working piece of code, but something which hopefully facilitates progress by providing a robust infrastructure.</p>
<p>The analogies I touched upon originate from <span class="bibref"><a href="#ja">Mathematics and the formal turn</a></span>, which discusses the future of mathematics, in light of formal verification methods.</p>
<p>I hope, you find the topic as intriguing as I did, when I saw the similarites for the first time.</p>
<h2 id="references"><a href="#references" class="header-anchor">References</a></h2>
<ul>
<li><p><a id="ha" class="anchor"></a> Paul R. Halmos, How to Write Mathematics. <a href="https://sites.math.washington.edu/~lind/Resources/Halmos.pdf">pdf</a></p>
</li>
<li><p><a id="swe" class="anchor"></a> John Ousterhout. A Philosophy of Software Design. 2018</p>
</li>
<li><p><a id="ja" class="anchor"></a> Jeremy Avigad. Mathematics and the formal turn. 2023. <a href="https://arxiv.org/abs/2311.00007">arXiv</a></p>
</li>
</ul>
<div class="page-foot">
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Samuel Belko. Last modified: April 25, 2025.
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
</div>
</div><!-- CONTENT ENDS HERE -->
    
    
  </body>
</html>
